{% extends "base.html" %}

{% block content %}
<div class="card">
    <h2>My Files</h2>

    <div style="margin-bottom: 20px;">
        <strong>Storage Usage:</strong> {{ (user.used_bytes / 1024 / 1024)|round(2) }} MB / {{ (user.quota_bytes / 1024
        / 1024 / 1024)|round(2) }} GB
        <div class="quota-bar">
            <div class="quota-fill" style="width: {{ (user.used_bytes / user.quota_bytes * 100)|round(2) }}%"></div>
        </div>
    </div>

    <form id="upload-form" class="upload-form">
        <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
        <div class="form-group">
            <label for="file">Upload Files</label>
            <input type="file" id="file" name="file" multiple required>
        </div>
        <div style="display: flex; gap: 10px;">
            <button type="submit" class="btn btn-primary" id="upload-btn">Upload</button>
            <button type="button" class="btn btn-danger" id="cancel-btn" style="display: none;">Cancel</button>
        </div>
    </form>

    <!-- Upload Progress -->
    <div id="upload-progress" style="display: none; margin-top: 20px;">
        <div style="margin-bottom: 10px;">
            <strong>Current File:</strong> <span id="current-filename"></span><br>
            <strong>Progress:</strong> <span id="progress-percent">0</span>%
            (<span id="files-processed">0</span>/<span id="total-files">0</span> files)
        </div>
        <div class="quota-bar">
            <div id="progress-bar" class="quota-fill" style="width: 0%; background-color: #4CAF50;"></div>
        </div>
        <div style="margin-top: 10px;">
            <strong>Speed:</strong> <span id="upload-speed">0</span> Mbps
        </div>
    </div>

    <table>
        <thead>
            <tr>
                <th>Filename</th>
                <th>Size</th>
                <th>Share</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            {% for file in files %}
            <tr>
                <td>{{ file.name }}</td>
                <td>{{ (file.size / 1024 / 1024)|round(2) }} MB</td>
                <td>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap; align-items: center;">
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <input type="checkbox" id="share-{{ loop.index }}" {% if file.share_token %}checked{% endif
                                %} onchange="toggleShare('{{ file.name }}', this.checked)" style="cursor: pointer;">
                            <label for="share-{{ loop.index }}"
                                style="margin: 0; cursor: pointer; font-size: 12px;">Share</label>
                        </div>

                        {% if file.share_token %}
                        <button
                            onclick="copyShareLink('{{ url_for('main.public_download', token=file.share_token, _external=True) }}')"
                            class="btn btn-secondary" style="padding: 4px 8px; font-size: 12px;">Copy Link</button>
                        {% endif %}
                    </div>
                </td>
                <td>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <a href="{{ url_for('main.download_file', filename=file.name) }}" class="btn btn-primary"
                            style="padding: 4px 8px; font-size: 12px;">Download</a>

                        <form action="{{ url_for('main.delete_file', filename=file.name) }}" method="POST"
                            style="display: inline;">
                            <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
                            <button type="submit" class="btn btn-danger" style="padding: 4px 8px; font-size: 12px;"
                                onclick="return confirm('Are you sure?')">Delete</button>
                        </form>
                    </div>
                </td>
            </tr>
            {% else %}
            <tr>
                <td colspan="4" style="text-align: center;">No files uploaded yet.</td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
</div>

<script>
    const csrfToken = document.querySelector('input[name="csrf_token"]').value;
    let isUploading = false;
    let abortController = null;
    let currentUploadId = null;

    window.onbeforeunload = function () {
        if (isUploading) {
            return "Upload in progress. Are you sure you want to leave? Your upload will be cancelled.";
        }
    };

    async function toggleShare(filename, shouldShare) {
        try {
            const formData = new FormData();
            formData.append('csrf_token', csrfToken);

            const url = shouldShare
                ? `/share/${encodeURIComponent(filename)}`
                : `/unshare/${encodeURIComponent(filename)}`;

            const response = await fetch(url, {
                method: 'POST',
                body: formData,
                headers: { 'X-Requested-With': 'XMLHttpRequest' }
            });

            const result = await response.json();
            if (result.status === 'success') {
                if (shouldShare && result.url) {
                    const message = `Share link generated:\n${result.url}\n\nYou can copy it using the "Copy Link" button.`;
                    alert(message);
                }
                location.reload();
            } else {
                alert('Error: ' + result.message);
                location.reload();
            }
        } catch (e) {
            alert('Error: ' + e.message);
            location.reload();
        }
    }

    function copyShareLink(url) {
        navigator.clipboard.writeText(url).then(() => {
            alert('Link copied to clipboard!');
        });
    }

    document.getElementById('upload-form').addEventListener('submit', async function (e) {
        e.preventDefault();
        if (isUploading) return;

        const fileInput = document.getElementById('file');
        const files = Array.from(fileInput.files);

        if (files.length === 0) {
            alert('Please select files');
            return;
        }

        isUploading = true;
        abortController = new AbortController();

        const progressDiv = document.getElementById('upload-progress');
        const progressBar = document.getElementById('progress-bar');
        const progressPercent = document.getElementById('progress-percent');
        const uploadSpeed = document.getElementById('upload-speed');
        const uploadBtn = document.getElementById('upload-btn');
        const cancelBtn = document.getElementById('cancel-btn');
        const currentFilenameSpan = document.getElementById('current-filename');
        const filesProcessedSpan = document.getElementById('files-processed');
        const totalFilesSpan = document.getElementById('total-files');

        progressDiv.style.display = 'block';
        uploadBtn.disabled = true;
        cancelBtn.style.display = 'inline-block';
        filesProcessedSpan.textContent = '0';
        totalFilesSpan.textContent = files.length;

        const CHUNK_SIZE = 2 * 1024 * 1024;
        const MAX_RETRIES = 3;

        try {
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                currentFilenameSpan.textContent = file.name;
                filesProcessedSpan.textContent = i + 1;

                progressBar.style.width = '0%';
                progressPercent.textContent = '0';

                const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
                currentUploadId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
                let chunksUploaded = 0;
                let lastUpdateTime = Date.now();
                let lastLoadedBytes = 0;
                const speedReadings = [];

                for (let chunkIdx = 0; chunkIdx < totalChunks; chunkIdx++) {
                    if (abortController.signal.aborted) throw new Error('Cancelled');

                    const start = chunkIdx * CHUNK_SIZE;
                    const end = Math.min(start + CHUNK_SIZE, file.size);
                    const chunk = file.slice(start, end);

                    const formData = new FormData();
                    formData.append('file', chunk);
                    formData.append('upload_id', currentUploadId);
                    formData.append('chunk_index', chunkIdx);
                    formData.append('csrf_token', csrfToken);

                    let uploaded = false;
                    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
                        try {
                            const response = await fetch('{{ url_for("main.upload_chunk") }}', {
                                method: 'POST',
                                body: formData,
                                headers: { 'X-Requested-With': 'XMLHttpRequest' },
                                signal: abortController.signal
                            });

                            if (!response.ok) {
                                const res = await response.json();
                                throw new Error(res.message || `HTTP ${response.status}`);
                            }
                            uploaded = true;
                            break;
                        } catch (err) {
                            if (attempt === MAX_RETRIES - 1 || abortController.signal.aborted) throw err;
                            await new Promise(r => setTimeout(r, 1000 * (attempt + 1)));
                        }
                    }

                    chunksUploaded++;

                    const percent = (chunksUploaded / totalChunks) * 100;
                    progressBar.style.width = percent + '%';
                    progressPercent.textContent = percent.toFixed(1);

                    const now = Date.now();
                    const timeDiff = (now - lastUpdateTime) / 1000;
                    if (timeDiff >= 0.5 || chunkIdx === totalChunks - 1) {
                        const loaded = Math.min((chunkIdx + 1) * CHUNK_SIZE, file.size);
                        const bytesDiff = loaded - lastLoadedBytes;
                        const speedMbps = (bytesDiff * 8) / (1024 * 1024) / timeDiff;

                        speedReadings.push(speedMbps);
                        if (speedReadings.length > 5) speedReadings.shift();
                        const avgSpeed = speedReadings.reduce((a, b) => a + b, 0) / speedReadings.length;

                        uploadSpeed.textContent = avgSpeed.toFixed(2);
                        lastUpdateTime = now;
                        lastLoadedBytes = loaded;
                    }
                }

                if (abortController.signal.aborted) throw new Error('Cancelled');

                const mergeData = new FormData();
                mergeData.append('upload_id', currentUploadId);
                mergeData.append('filename', file.name);
                mergeData.append('total_chunks', totalChunks);
                mergeData.append('csrf_token', csrfToken);

                const mergeRes = await fetch('{{ url_for("main.upload_merge") }}', {
                    method: 'POST',
                    body: mergeData,
                    headers: { 'X-Requested-With': 'XMLHttpRequest' },
                    signal: abortController.signal
                });

                if (!mergeRes.ok) {
                    const res = await mergeRes.json();
                    throw new Error(res.message || 'Merge failed');
                }
            }

            alert('All files uploaded successfully!');
            isUploading = false;
            location.reload();

        } catch (error) {
            if (error.message === 'Cancelled') {
                console.log('Upload cancelled');
            } else {
                alert('Upload failed: ' + error.message);
            }
        } finally {
            isUploading = false;
            uploadBtn.disabled = false;
            cancelBtn.style.display = 'none';
            progressDiv.style.display = 'none';
            currentUploadId = null;
        }
    });

    document.getElementById('cancel-btn').addEventListener('click', async function () {
        if (!isUploading) return;

        if (confirm('Are you sure you want to cancel the upload?')) {
            abortController.abort();
            isUploading = false;

            if (currentUploadId) {
                const formData = new FormData();
                formData.append('upload_id', currentUploadId);
                formData.append('csrf_token', csrfToken);

                try {
                    await fetch('{{ url_for("main.upload_cancel") }}', {
                        method: 'POST',
                        body: formData,
                        headers: { 'X-Requested-With': 'XMLHttpRequest' }
                    });
                } catch (e) {
                    console.error('Cleanup failed', e);
                }
            }

            document.getElementById('upload-progress').style.display = 'none';
            document.getElementById('upload-btn').disabled = false;
            this.style.display = 'none';
        }
    });
</script>
{% endblock %}