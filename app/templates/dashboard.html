{% extends "base.html" %}

{% block content %}
<div class="card">
    <h2>My Files</h2>

    <div style="margin-bottom: 20px;">
        <strong>Storage Usage:</strong> {{ (user.used_bytes / 1024 / 1024)|round(2) }} MB / {{ (user.quota_bytes / 1024
        / 1024 / 1024)|round(2) }} GB
        <div class="quota-bar">
            <div class="quota-fill" style="width: {{ (user.used_bytes / user.quota_bytes * 100)|round(2) }}%"></div>
        </div>
    </div>

    <form id="upload-form" method="POST" action="{{ url_for('main.upload_file') }}" enctype="multipart/form-data"
        class="upload-form">
        <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
        <div class="form-group">
            <label for="file">Upload File</label>
            <input type="file" id="file" name="file" required>
        </div>
        <button type="submit" class="btn btn-primary" id="upload-btn">Upload</button>
    </form>

    <!-- Upload Progress -->
    <div id="upload-progress" style="display: none; margin-top: 20px;">
        <div style="margin-bottom: 10px;">
            <strong>Upload Progress:</strong> <span id="progress-percent">0</span>%
        </div>
        <div class="quota-bar">
            <div id="progress-bar" class="quota-fill" style="width: 0%; background-color: #4CAF50;"></div>
        </div>
        <div style="margin-top: 10px;">
            <strong>Speed:</strong> <span id="upload-speed">0</span> Mbps
        </div>
    </div>

    <table>
        <thead>
            <tr>
                <th>Filename</th>
                <th>Size</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            {% for file in files %}
            <tr>
                <td>{{ file.name }}</td>
                <td>{{ (file.size / 1024 / 1024)|round(2) }} MB</td>
                <td>
                    <a href="{{ url_for('main.download_file', filename=file.name) }}" class="btn btn-primary"
                        style="padding: 4px 8px; font-size: 12px;">Download</a>
                    <form action="{{ url_for('main.delete_file', filename=file.name) }}" method="POST"
                        style="display: inline;">
                        <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
                        <button type="submit" class="btn btn-danger" style="padding: 4px 8px; font-size: 12px;"
                            onclick="return confirm('Are you sure?')">Delete</button>
                    </form>
                </td>
            </tr>
            {% else %}
            <tr>
                <td colspan="3" style="text-align: center;">No files uploaded yet.</td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
</div>

<script>
    document.getElementById('upload-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const fileInput = document.getElementById('file');
        const file = fileInput.files[0];

        if (!file) {
            alert('Please select a file');
            return;
        }

        // Configuration
        const CHUNK_SIZE = 2 * 1024 * 1024; // 2MB
        const MAX_RETRIES = 3;

        // UI Elements
        const progressDiv = document.getElementById('upload-progress');
        const progressBar = document.getElementById('progress-bar');
        const progressPercent = document.getElementById('progress-percent');
        const uploadSpeed = document.getElementById('upload-speed');
        const uploadBtn = document.getElementById('upload-btn');
        const csrfToken = document.querySelector('input[name="csrf_token"]').value;

        // State
        const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
        const uploadId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
        let chunksUploaded = 0;
        let startTime = Date.now();
        let lastUpdateTime = startTime;
        let lastLoadedBytes = 0;

        // Speed smoothing
        const speedReadings = [];
        const MAX_SPEED_READINGS = 5;

        // Reset UI
        progressDiv.style.display = 'block';
        uploadBtn.disabled = true;
        uploadBtn.textContent = 'Uploading...';
        progressBar.style.width = '0%';
        progressPercent.textContent = '0';
        uploadSpeed.textContent = '0';

        // Helper: Upload a single chunk
        async function uploadChunk(chunkIndex, start, end) {
            const chunk = file.slice(start, end);
            const formData = new FormData();
            formData.append('file', chunk);
            formData.append('upload_id', uploadId);
            formData.append('chunk_index', chunkIndex);
            formData.append('csrf_token', csrfToken);

            for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
                try {
                    const response = await fetch('{{ url_for("main.upload_chunk") }}', {
                        method: 'POST',
                        body: formData,
                        headers: {
                            'X-Requested-With': 'XMLHttpRequest'
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();
                    if (result.status !== 'success') {
                        throw new Error(result.message || 'Unknown error');
                    }
                    return; // Success
                } catch (error) {
                    console.error(`Chunk ${chunkIndex} attempt ${attempt + 1} failed:`, error);
                    if (attempt === MAX_RETRIES - 1) throw error;
                    await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1))); // Exponential backoff
                }
            }
        }

        try {
            for (let i = 0; i < totalChunks; i++) {
                const start = i * CHUNK_SIZE;
                const end = Math.min(start + CHUNK_SIZE, file.size);

                await uploadChunk(i, start, end);

                chunksUploaded++;

                // Update Progress
                const percentComplete = (chunksUploaded / totalChunks) * 100;
                progressBar.style.width = percentComplete + '%';
                progressPercent.textContent = percentComplete.toFixed(1);

                // Update Speed (Smoothed)
                const currentTime = Date.now();
                const timeDiff = (currentTime - lastUpdateTime) / 1000; // seconds

                if (timeDiff >= 0.5 || i === totalChunks - 1) { // Update every 500ms or at end
                    const totalUploadedSoFar = Math.min((i + 1) * CHUNK_SIZE, file.size);
                    const bytesDiffForSpeed = totalUploadedSoFar - lastLoadedBytes;

                    const speedBps = bytesDiffForSpeed / timeDiff;
                    const speedMbps = (speedBps * 8) / (1024 * 1024);

                    // Smoothing
                    speedReadings.push(speedMbps);
                    if (speedReadings.length > MAX_SPEED_READINGS) speedReadings.shift();
                    const avgSpeed = speedReadings.reduce((a, b) => a + b, 0) / speedReadings.length;

                    uploadSpeed.textContent = avgSpeed.toFixed(2);

                    lastUpdateTime = currentTime;
                    lastLoadedBytes = totalUploadedSoFar;
                }
            }

            // All chunks uploaded, trigger merge
            uploadBtn.textContent = 'Processing...';

            const formData = new FormData();
            formData.append('upload_id', uploadId);
            formData.append('filename', file.name);
            formData.append('total_chunks', totalChunks);
            formData.append('csrf_token', csrfToken);

            const response = await fetch('{{ url_for("main.upload_merge") }}', {
                method: 'POST',
                body: formData,
                headers: {
                    'X-Requested-With': 'XMLHttpRequest'
                }
            });

            if (!response.ok) throw new Error(`Merge failed: ${response.status}`);

            const result = await response.json();
            if (result.status === 'success') {
                alert('File uploaded successfully!');
                location.reload();
            } else {
                throw new Error(result.message || 'Merge failed');
            }

        } catch (error) {
            alert('Upload failed: ' + error.message);
            progressDiv.style.display = 'none';
            uploadBtn.disabled = false;
            uploadBtn.textContent = 'Upload';
        }
    });
</script>
{% endblock %}